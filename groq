#!/usr/bin/env perl

#-------------------------------------------------------------------------------
# This script provides command-line access to the Groq API for chat
# completions. It can accept input as a parameter or from standard input,
# allowing it to be used in a pipeline.
#
# It uses only modules from the standard library, so it requires no external
# dependencies. It should function on any system with a complete Perl v5.14
# installation.
#
# It optionally uses glow to format its output in an interactive terminal. If
# glow is not installed, will output markdown-formatted text.
#-------------------------------------------------------------------------------

use strict;
use warnings;
use v5.14;

use Getopt::Long    qw(GetOptions);
use HTTP::Tiny      qw();
use JSON::PP        qw(decode_json encode_json);
use Pod::Usage      qw(pod2usage);
use Term::ANSIColor qw(:constants);

#-------------------------------------------------------------------------------
# Constants
#-------------------------------------------------------------------------------
use constant THOUGHT_MAX_TOKENS => 2_000;
use constant DEFAULT_MODEL      => "deepseek-r1-distill-llama-70b";

#-------------------------------------------------------------------------------
# Command-line options
#-------------------------------------------------------------------------------
my $help;
my $query;
my $model;
my $rounds;
my @files;
my $list_models;

GetOptions(
  'h|help'      => \$help,
  'q|query=s'   => \$query,
  'm|model=s'   => \$model,
  'r|rounds=i'  => \$rounds,
  'f|file=s'    => \@files,
  'list-models' => \$list_models,
) or pod2usage(2);

pod2usage(1) if $help;

#-------------------------------------------------------------------------------
# Validation, initialization, and configuration
#-------------------------------------------------------------------------------
$model //= DEFAULT_MODEL;

pod2usage("--query is required", -exitval => 2)
  if !$query          # ...query is not set
  && !$list_models    # ...and we aren't using a different subcommand
  && -t;              # ...and we are connected to a terminal

for my $file (@files) {
  unless (-e $file) {
    die "File not found: $file\n";
  }
}

# Prevents groq from formatting LLM output with glow when not connected to a
# terminal or if glow is not installed.
my $USE_GLOW = -t STDOUT && system('which glow > /dev/null 2>&1') == 0;

# Set UTF-8 encoding for STDOUT since LLMs like their emojis
binmode STDOUT, ':encoding(UTF-8)';

#-------------------------------------------------------------------------------
# GROQ API and model configuration
#-------------------------------------------------------------------------------
my $ROUNDS      = $rounds || 3;
my $QUERY       = $query;
my $API_KEY     = $ENV{GROQ_API_KEY} // die "GROQ_API_KEY not set\n";
my $COMPLETIONS = 'https://api.groq.com/openai/v1/chat/completions';
my $MODELS      = 'https://api.groq.com/openai/v1/models';

my $THINK_PROMPT = qq{
  You are an AI assistant that reasons through problems step by step.

  Carefully examine the user's query.
  Are there invalid assumptions or logical fallacies?
  Politely correct the user's assumptions.

  Before answering, you must think inside <think>...</think> tags.
  Do not finalize your response until explicitly instructed.
};

my $KEEP_THINKING_PROMPT = qq{
  Reexamine the user's query and your previous thoughts.
  Is your reasoning in line with the user's needs?
  Are there any other factors to consider?
  Continue thinking.
};

my $FINALIZE_PROMPT = q{
  **Do not think any further.**
  Finalize your response to the user.
  Organize your response to be well-structured and clearly articulated.
  Use concise phrasing and avoid unnecessary repetition.
  Never use smart quotes or other typographic frippery and furbelows.
  Respond in formatted markdown.
};

#-------------------------------------------------------------------------------
# HTTP setup
#-------------------------------------------------------------------------------
my $HEADERS = {
  'Content-Type'  => 'application/json',
  'Authorization' => "Bearer $API_KEY",
};

my $HTTP = HTTP::Tiny->new(
  keep_alive      => 1,
  default_headers => $HEADERS,
);

#-------------------------------------------------------------------------------
# Message types
#-------------------------------------------------------------------------------
sub sys_msg{ {role => 'system',    content => $_[0]} }
sub ast_msg{ {role => 'assistant', content => $_[0]} }
sub usr_msg{ {role => 'user',      content => $_[0]} }

#-------------------------------------------------------------------------------
# API Functions
#-------------------------------------------------------------------------------
sub get{ $HTTP->get(@_) }
sub post{ $HTTP->post(@_) }

sub get_models {
  my $response = get($MODELS);

  die "$response->{status} $response->{reason}"
    unless $response->{success};

  my $data = decode_json($response->{content});

  sort map{ $_->{id} } @{$data->{data}};
}

sub get_completion {
  my ($msgs, %args) = @_;

  my $payload = encode_json{
    model    => $model,
    messages => $msgs,
    %args,
  };

  my $response = post($COMPLETIONS, {content => $payload});

  die "$response->{status} $response->{reason}"
    unless $response->{success};

  my $data = decode_json($response->{content});
  return $data->{choices}[0]{message}{content};
}

sub think {
  my $msgs  = shift;

  my $res = get_completion($msgs,
    max_completion_tokens => THOUGHT_MAX_TOKENS,
  );

  $res =~ s/^\s*<think>//s;
  $res =~ s/<\/think>.*\z//s;
  $res =~ s/^\s+//;
  $res =~ s/\s+\z//;

  return $res;
}

sub consider {
  my $query = shift;

  my $msgs = [
    sys_msg($THINK_PROMPT),
    file_msgs(),
    usr_msg($query),
  ];

  for (my $round = 1; $round <= $ROUNDS; ++$round) {
    my $thought = think($msgs);
    push @$msgs, ast_msg("<think>$thought</think>");

    if ($round != $ROUNDS) {
      push @$msgs, usr_msg($KEEP_THINKING_PROMPT);
    }

    print_thought($thought);
  }

  push @$msgs, usr_msg($FINALIZE_PROMPT);
  my $answer = get_completion($msgs);
  print_msg($answer);
}

sub file_msgs {
  my @msgs;

  for my $file (@files) {
    my $contents = do {
      local $/;
      open my $fh, '<', $file or die "Can't open $file: $!";
      <$fh>;
    };

    push @msgs, usr_msg(qq{
      # File: $file
      ```
      $contents
      ```
    });
  }

  @msgs;
}

#-------------------------------------------------------------------------------
# Output Functions
#-------------------------------------------------------------------------------
sub print_thought {
  my $thought = shift;
  print STDERR BOLD ITALIC "Thinking...", RESET, "\n\n";
  print STDERR FAINT $thought, RESET, "\n\n";
}

sub print_msg {
  my $msg = shift // return;
  $USE_GLOW ? glow($msg) : print("$msg");
}

sub glow {
  my $msg = shift // return;
  open my $pipe, '|-', 'glow' or die "Failed to open pipe to glow: $!";
  binmode $pipe, ':encoding(UTF-8)';
  print $pipe $msg;
  close $pipe;
  return;
}

#-------------------------------------------------------------------------------
# Commands
#-------------------------------------------------------------------------------
sub answer {
  if ($QUERY) {
    consider($QUERY);
  }

  unless (-t STDIN) {
    while (defined(my $query = <STDIN>)) {
      chomp $query;

      if ($query) {
        consider($query);
      }
    }
  }
}

sub list_models {
  my @models = get_models();

  if ($USE_GLOW) {
    my $md = join("\n", map{ "  - $_" } @models);
    glow($md);
    return;
  }

  print "$_\n"
    for @models;
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------
if ($list_models) {
  list_models();
} else {
  answer();
}

__END__

=head1 NAME

groq - A script to interact with the Groq API

=head1 SYNOPSIS

  groq [options]

 Options:
   --help        | -h  Display this help message
   --query       | -q  Prompt to send to the API (required)
   --model       | -m  Model to use (default: llama-3.3-70b-specdec)
   --rounds      | -r  Number of rounds of thinking (default: 3)
   --file        | -f  Include a file's contents in your query; can be used multiple times
   --list-models       List available models

=head1 DESCRIPTION

This script interacts with the Groq API to send prompts and receive responses.

=head1 OUTPUT FORMATTING

If L<glow|https://github.com/charmbracelet/glow> is installed, it will be used
for format the output. Otherwise, the output will be markdown-formatted text.

Well, I<probably> markdown-formatted text. The LLM may have other ideas.

=head2 REASONING

This script will perform C<rounds> rounds of reasoning before responding to the
query. Reasoning steps are emitted to C<STDERR>, while the final response is
printed to C<STDOUT>.

=head1 REDIRECTED I/O

Alternately, you can pipe a prompt into the script:

  echo "What is the meaning of life?" | groq

C<groq> will generate a response for each line of input:

  echo -e "What is the meaning of life?\nWhat is the airspeed velocity of an unladen swallow?" | groq

=cut
