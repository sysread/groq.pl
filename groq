#!/usr/bin/env perl

#-------------------------------------------------------------------------------
# This script provides command-line access to the Groq API for chat
# completions. It can accept input as a parameter or from standard input,
# allowing it to be used in a pipeline.
#
# It uses only modules from the standard library, so it requires no external
# dependencies. It should function on any system with a complete Perl v5.14
# installation.
#
# It optionally uses glow to format its output in an interactive terminal. If
# glow is not installed, will output markdown-formatted text.
#-------------------------------------------------------------------------------

use strict;
use warnings;
use v5.14;

use Getopt::Long    qw(GetOptions);
use HTTP::Tiny      qw();
use JSON::PP        qw(decode_json encode_json);
use Pod::Usage      qw(pod2usage);
use Term::ANSIColor qw(:constants);

#-------------------------------------------------------------------------------
# Constants
#-------------------------------------------------------------------------------
use constant THOUGHT_MAX_COMPLETION_TOKENS => 2_000;

#-------------------------------------------------------------------------------
# Command-line options
#-------------------------------------------------------------------------------
my $help;
my $query;
my $model;
my $rounds;
my @files;
my $list_models;

GetOptions(
  'h|help'      => \$help,
  'q|query=s'   => \$query,
  'm|model=s'   => \$model,
  'r|rounds=i'  => \$rounds,
  'f|file=s'    => \@files,
  'list-models' => \$list_models,
) or pod2usage(2);

pod2usage(1) if $help;

#-------------------------------------------------------------------------------
# Validation, initialization, and configuration
#-------------------------------------------------------------------------------
if (!$list_models && -t && !$query) {
  pod2usage("--query is required", -exitval => 2);
}

for my $file (@files) {
  unless (-e $file) {
    die "File not found: $file\n";
  }
}

my $USE_GLOW = -t STDOUT
  && system('which glow > /dev/null 2>&1') == 0;

binmode STDOUT, ':encoding(UTF-8)';

#-------------------------------------------------------------------------------
# GROQ API and model configuration
#-------------------------------------------------------------------------------
my $DEFAULT_MODEL = "deepseek-r1-distill-llama-70b";
my $MODEL         = $model  || $DEFAULT_MODEL;
my $ROUNDS        = $rounds || 3;
my $QUERY         = $query;
my $API_KEY       = $ENV{GROQ_API_KEY} // die "GROQ_API_KEY not set\n";
my $COMPLETIONS   = 'https://api.groq.com/openai/v1/chat/completions';
my $MODELS        = 'https://api.groq.com/openai/v1/models';

my $THINK_PROMPT = qq{
  You are an AI assistant that reasons through problems step by step.

  Carefully examine the user's query.
  Are there invalid assumptions or logical fallacies that indicate a need to politely correct the user's assumptions before proceeding?

  Before answering, you must think inside <think>...</think> tags.
  Do not finalize your response until explicitly instructed.
};

my $KEEP_THINKING_PROMPT = qq{
  Reexamine the user's query and your previous thoughts.
  Is your reasoning in line with the user's needs?
  Are there any other factors to consider?
  Continue thinking.
};

my $FINALIZE_PROMPT = q{
  **Do not think any further.**
  Finalize your response to the user.
  This will be shown to the user; ensure it is well-structured and clearly articulated.
  Respond in beautifully formatted markdown.
};

#-------------------------------------------------------------------------------
# HTTP setup
#-------------------------------------------------------------------------------
my $HEADERS = {
  'Content-Type'  => 'application/json',
  'Authorization' => "Bearer $API_KEY",
};

my $HTTP = HTTP::Tiny->new(
  keep_alive      => 1,
  default_headers => $HEADERS,
);

#-------------------------------------------------------------------------------
# Message types
#-------------------------------------------------------------------------------
sub sys_msg{ {role => 'system',    content => $_[0]} }
sub ast_msg{ {role => 'assistant', content => $_[0]} }
sub usr_msg{ {role => 'user',      content => $_[0]} }

#-------------------------------------------------------------------------------
# API Functions
#-------------------------------------------------------------------------------
sub get_models {
  my $response = $HTTP->get($MODELS);

  die "$response->{status} $response->{reason}"
    unless $response->{success};

  my $data = decode_json($response->{content});

  return
    sort { $a cmp $b }
    map  { $_->{id} }
         @{$data->{data}};
}

sub get_completion {
  my ($msgs, %args) = @_;

  my $payload = encode_json {
    model    => $MODEL,
    messages => $msgs,
    %args,
  };

  my $response = $HTTP->post($COMPLETIONS, {content => $payload});

  die "$response->{status} $response->{reason}"
    unless $response->{success};

  my $data = decode_json($response->{content});
  return $data->{choices}[0]{message}{content};
}

sub think {
  my $msgs  = shift;

  my $res = get_completion($msgs,
    max_completion_tokens => THOUGHT_MAX_COMPLETION_TOKENS,
  );

  $res =~ s/^\s*<think>//s;
  $res =~ s/<\/think>.*\z//s;
  $res =~ s/^\s+//;
  $res =~ s/\s+\z//;

  return $res;
}

sub consider {
  my $query = shift;

  my $msgs = [
    sys_msg($THINK_PROMPT),
    file_msgs(),
    usr_msg($query),
  ];

  for (my $round = 1; $round <= $ROUNDS; ++$round) {
    my $thought = think($msgs);
    push @$msgs, ast_msg("<think>$thought</think>");

    if ($round != $ROUNDS) {
      push @$msgs, usr_msg($KEEP_THINKING_PROMPT);
    }

    print_thought($thought);
  }

  push @$msgs, usr_msg($FINALIZE_PROMPT);
  my $answer = get_completion($msgs);
  print_msg($answer);
}

sub file_msgs {
  my @msgs;

  for my $file (@files) {
    my $contents = do {
      local $/;
      open my $fh, '<', $file or die "Can't open $file: $!";
      <$fh>;
    };

    push @msgs, usr_msg(qq{
      # File: $file
      ```
      $contents
      ```
    });
  }

  @msgs;
}

#-------------------------------------------------------------------------------
# Output Functions
#-------------------------------------------------------------------------------
sub print_thought {
  my $thought = shift;
  print BOLD ITALIC "Thinking...", RESET, "\n\n";
  print FAINT $thought, RESET, "\n\n";
}

sub print_msg {
  my $msg = shift // return;

  if ($USE_GLOW) {
    glow($msg);
    return;
  }

  print "$msg";
}

sub glow {
  my $msg = shift // return;
  open my $pipe, '|-', 'glow' or die "Failed to open pipe to glow: $!";
  binmode $pipe, ':encoding(UTF-8)';
  print $pipe $msg;
  close $pipe;
  return;
}

#-------------------------------------------------------------------------------
# Commands
#-------------------------------------------------------------------------------
sub answer {
  if ($QUERY) {
    consider($QUERY);
  }

  unless (-t STDIN) {
    while (defined(my $query = <STDIN>)) {
      chomp $query;

      if ($query) {
        consider($query);
      }
    }
  }
}

sub list_models {
  my @models = get_models();

  if ($USE_GLOW) {
    my $md = join("\n", map{ "  - $_" } @models);
    glow($md);
    return;
  }

  print "$_\n"
    for @models;
}

#-------------------------------------------------------------------------------
# Main
#-------------------------------------------------------------------------------
if ($list_models) {
  list_models();
} else {
  answer();
}

__END__

=head1 NAME

groq - A script to interact with the Groq API

=head1 SYNOPSIS

  groq [options]

 Options:
   --help        | -h  Display this help message
   --query       | -q  Prompt to send to the API (required)
   --model       | -m  Model to use (default: llama-3.3-70b-specdec)
   --rounds      | -r  Number of rounds of thinking (default: 3)
   --file        | -f  Include a file's contents in your query; can be used multiple times
   --list-models       List available models

=head1 DESCRIPTION

This script interacts with the Groq API to send prompts and receive responses.

=head1 OUTPUT FORMATTING

If L<glow|https://github.com/charmbracelet/glow> is installed, it will be used
for format the output. Otherwise, the output will be markdown-formatted text.

Well, I<probably> markdown-formatted text. The LLM may have other ideas.

=head1 REDIRECTED I/O

Alternately, you can pipe a prompt into the script:

  echo "What is the meaning of life?" | groq

C<groq> will generate a response for each line of input:

  echo -e "What is the meaning of life?\nWhat is the airspeed velocity of an unladen swallow?" | groq

=cut
